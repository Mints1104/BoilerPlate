{"version":3,"file":"Contact-DdKH8KDP.js","sources":["../../src/services/contactForm.service.ts","../../src/utils/validation.ts","../../src/utils/security.ts","../../src/hooks/useContactForm.ts","../../src/components/ui/ContactForm.tsx","../../src/components/pages/Contact.tsx"],"sourcesContent":["// Contact Form Service - Supports multiple backends\n// Choose your backend in .env.local\n\nexport type ContactFormProvider =\n  | 'formspree'\n  | 'getform'\n  | 'web3forms'\n  | 'custom'\n  | 'netlify'\n  | 'vercel'\n\nexport interface ContactFormData {\n  name: string\n  email: string\n  subject?: string\n  message: string\n  phone?: string\n  [key: string]: string | undefined\n}\n\nexport interface ContactFormResponse {\n  success: boolean\n  message: string\n  error?: string\n}\n\n/**\n * Formspree integration\n * https://formspree.io/\n */\nconst submitToFormspree = async (\n  data: ContactFormData\n): Promise<ContactFormResponse> => {\n  const formId = import.meta.env.VITE_FORMSPREE_ID\n\n  if (!formId) {\n    throw new Error('Formspree ID not configured')\n  }\n\n  const response = await fetch(`https://formspree.io/f/${formId}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  })\n\n  if (response.ok) {\n    return {\n      success: true,\n      message: 'Thank you! Your message has been sent successfully.',\n    }\n  }\n\n  const error = await response.json()\n  return {\n    success: false,\n    message: 'Failed to send message. Please try again.',\n    error: error.error || 'Unknown error',\n  }\n}\n\n/**\n * Getform integration\n * https://getform.io/\n */\nconst submitToGetform = async (\n  data: ContactFormData\n): Promise<ContactFormResponse> => {\n  const endpoint = import.meta.env.VITE_GETFORM_ENDPOINT\n\n  if (!endpoint) {\n    throw new Error('Getform endpoint not configured')\n  }\n\n  const response = await fetch(endpoint, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  })\n\n  if (response.ok) {\n    return {\n      success: true,\n      message: 'Thank you! Your message has been sent successfully.',\n    }\n  }\n\n  return {\n    success: false,\n    message: 'Failed to send message. Please try again.',\n  }\n}\n\n/**\n * Web3Forms integration\n * https://web3forms.com/\n */\nconst submitToWeb3Forms = async (\n  data: ContactFormData\n): Promise<ContactFormResponse> => {\n  const accessKey = import.meta.env.VITE_WEB3FORMS_KEY\n\n  if (!accessKey) {\n    throw new Error('Web3Forms access key not configured')\n  }\n\n  const response = await fetch('https://api.web3forms.com/submit', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      access_key: accessKey,\n      ...data,\n    }),\n  })\n\n  const result = await response.json()\n\n  if (result.success) {\n    return {\n      success: true,\n      message: 'Thank you! Your message has been sent successfully.',\n    }\n  }\n\n  return {\n    success: false,\n    message: result.message || 'Failed to send message. Please try again.',\n  }\n}\n\n/**\n * Custom API integration\n */\nconst submitToCustomAPI = async (\n  data: ContactFormData\n): Promise<ContactFormResponse> => {\n  const apiUrl = import.meta.env.VITE_CONTACT_API_URL\n\n  if (!apiUrl) {\n    throw new Error('Custom API URL not configured')\n  }\n\n  const response = await fetch(apiUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(data),\n  })\n\n  if (!response.ok) {\n    return {\n      success: false,\n      message: 'Failed to send message. Please try again.',\n    }\n  }\n\n  const result = await response.json()\n  return {\n    success: true,\n    message:\n      result.message || 'Thank you! Your message has been sent successfully.',\n  }\n}\n\n/**\n * Netlify Forms integration\n * No API call needed - form submits directly to Netlify\n */\nconst submitToNetlify = async (\n  _data: ContactFormData\n): Promise<ContactFormResponse> => {\n  // This is handled by the form itself with data-netlify=\"true\"\n  // This function exists for consistency\n  return {\n    success: true,\n    message: 'Thank you! Your message has been sent successfully.',\n  }\n}\n\n/**\n * Main contact form submission handler\n */\nexport const submitContactForm = async (\n  data: ContactFormData,\n  provider: ContactFormProvider = 'formspree'\n): Promise<ContactFormResponse> => {\n  try {\n    switch (provider) {\n      case 'formspree':\n        return await submitToFormspree(data)\n      case 'getform':\n        return await submitToGetform(data)\n      case 'web3forms':\n        return await submitToWeb3Forms(data)\n      case 'custom':\n        return await submitToCustomAPI(data)\n      case 'netlify':\n        return await submitToNetlify(data)\n      default:\n        throw new Error(`Unknown provider: ${provider}`)\n    }\n  } catch (error) {\n    console.error('Contact form submission error:', error)\n    return {\n      success: false,\n      message: 'An error occurred. Please try again later.',\n      error: error instanceof Error ? error.message : 'Unknown error',\n    }\n  }\n}\n","// Form validation utilities\n\nexport interface ValidationRule {\n  required?: boolean\n  minLength?: number\n  maxLength?: number\n  pattern?: RegExp\n  custom?: (value: string) => boolean\n  message?: string\n}\n\nexport interface ValidationRules {\n  [fieldName: string]: ValidationRule\n}\n\nexport interface ValidationErrors {\n  [fieldName: string]: string\n}\n\n/**\n * Validates a single field against a rule\n */\nexport const validateField = (\n  value: string,\n  rule: ValidationRule,\n  fieldName: string\n): string | null => {\n  // Required check\n  if (rule.required && (!value || value.trim() === '')) {\n    return rule.message || `${fieldName} is required`\n  }\n\n  // If not required and empty, skip other validations\n  if (!value || value.trim() === '') {\n    return null\n  }\n\n  // Min length check\n  if (rule.minLength && value.length < rule.minLength) {\n    return (\n      rule.message ||\n      `${fieldName} must be at least ${rule.minLength} characters`\n    )\n  }\n\n  // Max length check\n  if (rule.maxLength && value.length > rule.maxLength) {\n    return (\n      rule.message ||\n      `${fieldName} must be no more than ${rule.maxLength} characters`\n    )\n  }\n\n  // Pattern check\n  if (rule.pattern && !rule.pattern.test(value)) {\n    return rule.message || `${fieldName} format is invalid`\n  }\n\n  // Custom validation\n  if (rule.custom && !rule.custom(value)) {\n    return rule.message || `${fieldName} is invalid`\n  }\n\n  return null\n}\n\n/**\n * Validates all fields against rules\n */\nexport const validateForm = (\n  formData: Record<string, string>,\n  rules: ValidationRules\n): { isValid: boolean; errors: ValidationErrors } => {\n  const errors: ValidationErrors = {}\n\n  Object.keys(rules).forEach((fieldName) => {\n    const value = formData[fieldName] || ''\n    const error = validateField(value, rules[fieldName], fieldName)\n\n    if (error) {\n      errors[fieldName] = error\n    }\n  })\n\n  return {\n    isValid: Object.keys(errors).length === 0,\n    errors,\n  }\n}\n\n/**\n * Common validation rules\n */\nexport const commonRules = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    message: 'Please enter a valid email address',\n  },\n  phone: {\n    pattern: /^[\\d\\s\\-+()]+$/,\n    minLength: 10,\n    message: 'Please enter a valid phone number',\n  },\n  name: {\n    required: true,\n    minLength: 2,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n    message: 'Please enter a valid name',\n  },\n  message: {\n    required: true,\n    minLength: 10,\n    maxLength: 1000,\n    message: 'Message must be between 10 and 1000 characters',\n  },\n}\n","// Security utilities and helpers\n\n/**\n * Sanitizes user input to prevent XSS attacks\n * Removes potentially dangerous characters and HTML tags\n */\nexport const sanitizeInput = (input: string): string => {\n  if (!input) return ''\n\n  // Remove HTML tags\n  let sanitized = input.replace(/<[^>]*>/g, '')\n\n  // Encode special characters\n  sanitized = sanitized\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;')\n    .replace(/\\//g, '&#x2F;')\n\n  return sanitized.trim()\n}\n\n/**\n * Validates email format\n */\nexport const isValidEmail = (email: string): boolean => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  return emailRegex.test(email)\n}\n\n/**\n * Validates phone number format (basic)\n */\nexport const isValidPhone = (phone: string): boolean => {\n  const phoneRegex = /^[\\d\\s\\-+()]+$/\n  return phoneRegex.test(phone) && phone.replace(/\\D/g, '').length >= 10\n}\n\n/**\n * Rate limiting helper for client-side form submissions\n * Prevents spam by limiting submissions per time window\n */\nclass RateLimiter {\n  private attempts: Map<string, number[]> = new Map()\n\n  canSubmit(\n    key: string,\n    maxAttempts: number = 3,\n    windowMs: number = 60000\n  ): boolean {\n    const now = Date.now()\n    const attempts = this.attempts.get(key) || []\n\n    // Filter out old attempts outside the time window\n    const recentAttempts = attempts.filter(\n      (timestamp) => now - timestamp < windowMs\n    )\n\n    if (recentAttempts.length >= maxAttempts) {\n      return false\n    }\n\n    // Add current attempt\n    recentAttempts.push(now)\n    this.attempts.set(key, recentAttempts)\n\n    return true\n  }\n\n  reset(key: string): void {\n    this.attempts.delete(key)\n  }\n}\n\nexport const formRateLimiter = new RateLimiter()\n\n/**\n * Generates a simple CSRF-like token for form submissions\n * Note: For production, use proper backend CSRF protection\n */\nexport const generateFormToken = (): string => {\n  const timestamp = Date.now()\n  const random = Math.random().toString(36).substring(2)\n  return `${timestamp}-${random}`\n}\n\n/**\n * Validates form token (basic check)\n * In production, validate on backend\n */\nexport const isValidFormToken = (\n  token: string,\n  maxAgeMs: number = 3600000\n): boolean => {\n  if (!token) return false\n\n  const [timestampStr] = token.split('-')\n  const timestamp = parseInt(timestampStr, 10)\n\n  if (isNaN(timestamp)) return false\n\n  const age = Date.now() - timestamp\n  return age >= 0 && age <= maxAgeMs\n}\n\n/**\n * Checks if content contains potential security threats\n */\nexport const containsSuspiciousContent = (content: string): boolean => {\n  const suspiciousPatterns = [\n    /<script/i,\n    /javascript:/i,\n    /on\\w+\\s*=/i, // Event handlers like onclick=\n    /data:text\\/html/i,\n    /<iframe/i,\n    /<embed/i,\n    /<object/i,\n  ]\n\n  return suspiciousPatterns.some((pattern) => pattern.test(content))\n}\n\n/**\n * Validates URL to prevent open redirects\n */\nexport const isValidUrl = (url: string): boolean => {\n  try {\n    const parsed = new URL(url)\n    // Only allow http and https protocols\n    return parsed.protocol === 'http:' || parsed.protocol === 'https:'\n  } catch {\n    return false\n  }\n}\n\n/**\n * Content Security Policy helper\n * Returns CSP meta tag content\n */\nexport const getCSPContent = (): string => {\n  return [\n    \"default-src 'self'\",\n    \"script-src 'self' 'unsafe-inline'\", // Vite requires unsafe-inline for dev\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data: https:\",\n    \"font-src 'self' data:\",\n    \"connect-src 'self' https:\",\n    \"frame-ancestors 'none'\",\n    \"base-uri 'self'\",\n    \"form-action 'self'\",\n  ].join('; ')\n}\n","import { useState } from 'react'\nimport {\n  ContactFormData,\n  ContactFormProvider,\n  submitContactForm,\n} from '@services/contactForm.service'\nimport { validateForm, commonRules, ValidationErrors } from '@utils/validation'\nimport {\n  sanitizeInput,\n  formRateLimiter,\n  containsSuspiciousContent,\n} from '@utils/security'\n\ninterface UseContactFormOptions {\n  provider?: ContactFormProvider\n  onSuccess?: () => void\n  onError?: (error: string) => void\n}\n\nexport const useContactForm = (options: UseContactFormOptions = {}) => {\n  const { provider = 'formspree', onSuccess, onError } = options\n\n  const [formData, setFormData] = useState<ContactFormData>({\n    name: '',\n    email: '',\n    subject: '',\n    message: '',\n    phone: '',\n  })\n\n  const [errors, setErrors] = useState<ValidationErrors>({})\n  const [isSubmitting, setIsSubmitting] = useState(false)\n  const [submitStatus, setSubmitStatus] = useState<{\n    type: 'success' | 'error' | null\n    message: string\n  }>({ type: null, message: '' })\n\n  const handleChange = (field: keyof ContactFormData, value: string) => {\n    setFormData((prev: ContactFormData) => ({ ...prev, [field]: value }))\n    // Clear error when user starts typing\n    if (errors[field as string]) {\n      setErrors((prev) => {\n        const newErrors = { ...prev }\n        delete newErrors[field as string]\n        return newErrors\n      })\n    }\n  }\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault()\n    setSubmitStatus({ type: null, message: '' })\n\n    // Rate limiting check\n    if (!formRateLimiter.canSubmit('contact-form', 3, 60000)) {\n      setSubmitStatus({\n        type: 'error',\n        message: 'Too many submissions. Please wait a minute and try again.',\n      })\n      return\n    }\n\n    // Security check - scan for suspicious content\n    if (containsSuspiciousContent(formData.message)) {\n      setSubmitStatus({\n        type: 'error',\n        message:\n          'Your message contains invalid content. Please remove any HTML or scripts.',\n      })\n      return\n    }\n\n    // Validate form\n    const validationRules = {\n      name: commonRules.name,\n      email: commonRules.email,\n      message: commonRules.message,\n      ...(formData.phone && { phone: commonRules.phone }),\n    }\n\n    const validation = validateForm(\n      formData as Record<string, string>,\n      validationRules\n    )\n\n    if (!validation.isValid) {\n      setErrors(validation.errors)\n      return\n    }\n\n    setIsSubmitting(true)\n\n    try {\n      // Sanitize all inputs before sending\n      const sanitizedData: ContactFormData = {\n        name: sanitizeInput(formData.name),\n        email: sanitizeInput(formData.email),\n        subject: formData.subject ? sanitizeInput(formData.subject) : undefined,\n        message: sanitizeInput(formData.message),\n        phone: formData.phone ? sanitizeInput(formData.phone) : undefined,\n      }\n\n      const response = await submitContactForm(sanitizedData, provider)\n\n      if (response.success) {\n        setSubmitStatus({ type: 'success', message: response.message })\n        // Reset form\n        setFormData({\n          name: '',\n          email: '',\n          subject: '',\n          message: '',\n          phone: '',\n        })\n        onSuccess?.()\n      } else {\n        setSubmitStatus({\n          type: 'error',\n          message: response.message,\n        })\n        onError?.(response.error || response.message)\n      }\n    } catch (error) {\n      setSubmitStatus({\n        type: 'error',\n        message: 'An unexpected error occurred. Please try again.',\n      })\n      onError?.(error instanceof Error ? error.message : 'Unknown error')\n    } finally {\n      setIsSubmitting(false)\n    }\n  }\n\n  const resetForm = () => {\n    setFormData({\n      name: '',\n      email: '',\n      subject: '',\n      message: '',\n      phone: '',\n    })\n    setErrors({})\n    setSubmitStatus({ type: null, message: '' })\n  }\n\n  return {\n    formData,\n    errors,\n    isSubmitting,\n    submitStatus,\n    handleChange,\n    handleSubmit,\n    resetForm,\n  }\n}\n","import { FormEvent, ChangeEvent } from 'react'\nimport { useContactForm } from '@hooks/useContactForm'\nimport styles from './ContactForm.module.css'\nimport Button from './Button'\n\ninterface ContactFormProps {\n  provider?: 'formspree' | 'getform' | 'web3forms' | 'custom' | 'netlify'\n  onSuccess?: () => void\n  onError?: (error: string) => void\n}\n\nexport default function ContactForm({\n  provider = 'formspree',\n  onSuccess,\n  onError,\n}: ContactFormProps) {\n  const {\n    formData,\n    errors,\n    isSubmitting,\n    submitStatus,\n    handleChange,\n    handleSubmit,\n  } = useContactForm({ provider, onSuccess, onError })\n\n  const onChange = (e: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n    const { name, value } = e.target\n    handleChange(name as keyof typeof formData, value)\n  }\n\n  const onSubmit = async (e: FormEvent) => {\n    await handleSubmit(e)\n  }\n\n  if (submitStatus.type === 'success') {\n    return (\n      <div className={styles.successMessage} role=\"alert\" aria-live=\"polite\">\n        <h3>Thank you!</h3>\n        <p>\n          Your message has been sent successfully. We'll get back to you soon.\n        </p>\n      </div>\n    )\n  }\n\n  return (\n    <form\n      className={styles.contactForm}\n      onSubmit={onSubmit}\n      noValidate\n      aria-label=\"Contact form\"\n    >\n      <div className={styles.formGroup}>\n        <label htmlFor=\"name\" className={styles.label}>\n          Name{' '}\n          <span className={styles.required} aria-label=\"required\">\n            *\n          </span>\n        </label>\n        <input\n          type=\"text\"\n          id=\"name\"\n          name=\"name\"\n          value={formData.name}\n          onChange={onChange}\n          className={`${styles.input} ${errors.name ? styles.inputError : ''}`}\n          aria-required=\"true\"\n          aria-invalid={!!errors.name}\n          aria-describedby={errors.name ? 'name-error' : undefined}\n          disabled={isSubmitting}\n        />\n        {errors.name && (\n          <span id=\"name-error\" className={styles.errorText} role=\"alert\">\n            {errors.name}\n          </span>\n        )}\n      </div>\n\n      <div className={styles.formGroup}>\n        <label htmlFor=\"email\" className={styles.label}>\n          Email{' '}\n          <span className={styles.required} aria-label=\"required\">\n            *\n          </span>\n        </label>\n        <input\n          type=\"email\"\n          id=\"email\"\n          name=\"email\"\n          value={formData.email}\n          onChange={onChange}\n          className={`${styles.input} ${errors.email ? styles.inputError : ''}`}\n          aria-required=\"true\"\n          aria-invalid={!!errors.email}\n          aria-describedby={errors.email ? 'email-error' : undefined}\n          disabled={isSubmitting}\n        />\n        {errors.email && (\n          <span id=\"email-error\" className={styles.errorText} role=\"alert\">\n            {errors.email}\n          </span>\n        )}\n      </div>\n\n      <div className={styles.formGroup}>\n        <label htmlFor=\"phone\" className={styles.label}>\n          Phone\n        </label>\n        <input\n          type=\"tel\"\n          id=\"phone\"\n          name=\"phone\"\n          value={formData.phone || ''}\n          onChange={onChange}\n          className={`${styles.input} ${errors.phone ? styles.inputError : ''}`}\n          aria-invalid={!!errors.phone}\n          aria-describedby={errors.phone ? 'phone-error' : undefined}\n          disabled={isSubmitting}\n        />\n        {errors.phone && (\n          <span id=\"phone-error\" className={styles.errorText} role=\"alert\">\n            {errors.phone}\n          </span>\n        )}\n      </div>\n\n      <div className={styles.formGroup}>\n        <label htmlFor=\"message\" className={styles.label}>\n          Message{' '}\n          <span className={styles.required} aria-label=\"required\">\n            *\n          </span>\n        </label>\n        <textarea\n          id=\"message\"\n          name=\"message\"\n          value={formData.message}\n          onChange={onChange}\n          rows={5}\n          className={`${styles.textarea} ${errors.message ? styles.inputError : ''}`}\n          aria-required=\"true\"\n          aria-invalid={!!errors.message}\n          aria-describedby={errors.message ? 'message-error' : undefined}\n          disabled={isSubmitting}\n        />\n        {errors.message && (\n          <span id=\"message-error\" className={styles.errorText} role=\"alert\">\n            {errors.message}\n          </span>\n        )}\n      </div>\n\n      {submitStatus.type === 'error' && (\n        <div className={styles.submitError} role=\"alert\" aria-live=\"polite\">\n          {submitStatus.message}\n        </div>\n      )}\n\n      <Button type=\"submit\" disabled={isSubmitting} aria-busy={isSubmitting}>\n        {isSubmitting ? 'Sending...' : 'Send Message'}\n      </Button>\n    </form>\n  )\n}\n","import ContactForm from '../ui/ContactForm'\nimport styles from './Contact.module.css'\n\nexport default function Contact() {\n  const handleSuccess = () => {\n    console.log('Form submitted successfully!')\n  }\n\n  const handleError = (error: string) => {\n    console.error('Form submission error:', error)\n  }\n\n  return (\n    <div className={styles.contact}>\n      <div className={styles.header}>\n        <h1>Contact Us</h1>\n        <p className={styles.subtitle}>\n          Have a question or want to work together? Send us a message!\n        </p>\n      </div>\n\n      <div className={styles.content}>\n        <ContactForm\n          provider=\"formspree\"\n          onSuccess={handleSuccess}\n          onError={handleError}\n        />\n      </div>\n\n      <div className={styles.info}>\n        <h2>Other Ways to Reach Us</h2>\n        <div className={styles.infoGrid}>\n          <div className={styles.infoCard}>\n            <h3>Email</h3>\n            <p>\n              <a href=\"mailto:hello@example.com\">hello@example.com</a>\n            </p>\n          </div>\n          <div className={styles.infoCard}>\n            <h3>Phone</h3>\n            <p>\n              <a href=\"tel:+1234567890\">+1 (234) 567-890</a>\n            </p>\n          </div>\n          <div className={styles.infoCard}>\n            <h3>Address</h3>\n            <p>\n              123 Main Street\n              <br />\n              City, State 12345\n              <br />\n              Country\n            </p>\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n"],"names":["submitContactForm","async","data","provider","Error","submitToFormspree","submitToGetform","submitToWeb3Forms","submitToCustomAPI","success","message","submitToNetlify","error","commonRules","email","required","pattern","phone","minLength","name","maxLength","sanitizeInput","input","sanitized","replace","trim","formRateLimiter","constructor","__publicField","this","Map","canSubmit","key","maxAttempts","windowMs","now","Date","recentAttempts","attempts","get","filter","timestamp","length","push","set","reset","delete","useContactForm","options","onSuccess","onError","formData","setFormData","useState","subject","errors","setErrors","isSubmitting","setIsSubmitting","submitStatus","setSubmitStatus","type","handleChange","field","value","prev","newErrors","handleSubmit","e","preventDefault","content","some","test","validationRules","validation","rules","Object","keys","forEach","fieldName","rule","custom","validateField","isValid","validateForm","response","sanitizedData","resetForm","ContactForm","onChange","target","jsxs","className","styles","role","children","jsx","onSubmit","noValidate","htmlFor","id","disabled","rows","Button","Contact","href"],"mappings":"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"}